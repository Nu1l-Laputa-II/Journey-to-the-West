### 1.2 算法与数据结构
#### 1.2.1 算法定义
- [ ] **本质**：解决特定问题的有限步骤指令集
- [ ] **核心特性**：
  - 输入/输出明确定义
  - 可行性（有限步骤/时间/空间）
  - 确定性（相同输入 → 相同输出）

#### 1.2.2 数据结构定义 → **<集合, 关系, 运算符>三元组**
- [ ] **数学形式化**：`DS = <D, R, O>`  
  - `D`：**数据集合**（存储的内容）
  - `R`：**数据关系**（元素间的逻辑/物理关联）
  - `O`：**运算符**（对数据的基本操作方法）
- [ ] **设计目标**：
  - 最小化空间占用（优化`D`存储）
  - 最大化操作效率（优化`O`性能）
  - 清晰表达逻辑关系（优化`R`表示）
- [ ] **设计权衡**（典型示例）：
  - 链表 vs 数组：  
    ✅ `O`更优（插入/删除快）  
    ❌ `R`更弱（访问效率低）  
  - 图 vs 链表：  
    ✅ `R`更丰富（多维度关系）  
    ❌ `D`更大（内存占用高）  

#### 1.2.3 数据结构与算法的关系
- [ ] **相互依存**：
  - ✅ 数据结构是算法基石 → 提供`<D, R, O>`基础
  - ✅ 算法赋予数据结构生命力 → 通过操作`O`解决问题
- [ ] **效率关联**：
  - 同一算法 + 不同`<D, R, O>` → 性能差异显著
  - 关键决策：选择最优`<D, R, O>`组合
- [ ] **积木模型类比**：
  | **概念** | **积木元素**      | **三元组映射**     |
  | -------- | ----------------- | ------------------ |
  | 输入数据 | 未拼装的积木      | 初始`D`集合        |
  | 数据结构 | 积木形状/连接方式 | `<D, R, O>`整体    |
  | 算法     | 拼装说明书步骤    | 对`O`的顺序调用    |
  | 输出数据 | 完成的积木模型    | 经`O`处理后的新`D` |

> **关键认知**  
> 1. **语言独立性**：  
>    - `<D, R, O>`设计与算法逻辑均独立于编程语言  
>    - 同一`<集合, 关系, 运算符>`可多语言实现  
> 2. 行业简称惯例：  
>    - "算法"实际包含数据结构与算法双维度（如LeetCode考查点）  
> 3. **三元组实践价值**：  
>    - 设计数据结构 → 明确`D`的存储范围、`R`的连接规则、`O`的原子操作  
>    - 优化算法 → 通过重组`R`减少计算量，或选择高效`O`组合

### 核心强调说明

1. **数据结构三元组**
   - **集合(D)**：数据元素的有限集（如数组的存储空间）
   - **关系(R)**：元素间的逻辑/物理关联（如链表的指针链接、树的父子层级）
   - **运算符(O)**：基本操作集合（如哈希表的put/get、栈的push/pop）
2. **设计权衡本质**
   - 增强`R`（如树→图）需牺牲`D`的空间效率
   - 优化`O`（如哈希表快速查找）需处理`R`的冲突问题
3. **算法交互逻辑**

```mermaid
graph LR
A[算法步骤] --> B[调用数据结构运算符O]
B --> C[改变数据关系R]
C --> D[更新数据集合D]
D --> A
```

