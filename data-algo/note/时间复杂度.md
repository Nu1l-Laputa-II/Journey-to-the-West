### 2.3 时间复杂度总结

#### **1. 核心思想**
- **目标**：评估算法运行时间随输入数据规模（n）的增长趋势，而非计算具体运行时间。
- **关键原则**：
  - 忽略与平台相关的常数项和系数。
  - 关注操作数量的最高阶项（主导项）。

#### **2. 时间复杂度的表示**
- **大 O 记号（O）**：描述算法的最坏情况时间复杂度（渐近上界）。
  - 例如：冒泡排序的时间复杂度为 O(n²)。
- **其他记号**：
  - Ω：最佳时间复杂度（渐近下界）。
  - Θ：平均时间复杂度（需数学推导，实际常用 O 代替）。

#### **3. 常见时间复杂度类型**
按效率从高到低排序：

| **类型**   | **表示**   | **示例场景**                   | **特点**                   |
| ---------- | ---------- | ------------------------------ | -------------------------- |
| 常数阶     | O(1)       | 固定次数的操作（如数组访问）   | 最优，与 n 无关            |
| 对数阶     | O(log n)   | 二分查找、分治算法（每轮减半） | 高效，仅次于 O(1)          |
| 线性阶     | O(n)       | 遍历数组、链表                 | 操作次数与 n 成正比        |
| 线性对数阶 | O(n log n) | 快速排序、归并排序             | 高效排序算法的典型复杂度   |
| 平方阶     | O(n²)      | 冒泡排序、嵌套循环             | 效率较低，n 较大时性能差   |
| 指数阶     | O(2ⁿ)      | 穷举法（如子集生成）           | 不可接受的高复杂度         |
| 阶乘阶     | O(n!)      | 全排列问题（递归回溯）         | 最高复杂度，仅适用于极小 n |

#### **4. 推算方法**
1. **统计操作数量**：
   - 忽略常数项和系数（如 5n² + 3n → n²）。
   - 嵌套循环使用乘法（外层 n 次，内层 n 次 → n²）。
2. **确定最高阶项**：
   - 例如：T(n) = 3n³ + 2n² + 100 → O(n³)。

#### **5. 最差、最佳与平均时间复杂度**
- **最差时间复杂度（O）**：算法在最坏输入下的表现（实际分析中最常用）。
- **最佳时间复杂度（Ω）**：算法在最优输入下的表现（如搜索时目标在第一个位置）。
- **平均时间复杂度（Θ）**：随机输入下的期望表现（需数学推导，常用 O 近似表示）。

#### **6. 示例对比**
- **线性搜索**：
  - 最差：O(n)（目标在末尾）。
  - 最佳：O(1)（目标在开头）。
  - 平均：O(n)（假设均匀分布）。
- **二分查找**：
  - 最差/平均：O(log n)（每次减半）。
  - 最佳：O(1)（直接命中中点）。

#### **7. 重要结论**
- **效率排序**：O(1) > O(log n) > O(n) > O(n log n) > O(n²) > O(2ⁿ) > O(n!)。
- **算法选择**：
  - 小规模数据：任何复杂度均可接受。
  - 大规模数据：优先选择 O(n log n) 或更低复杂度的算法。

#### **8. 注意事项**
- **大 O 的简化**：对数阶的底数可忽略（O(log₂n) ≡ O(log n)）。
- **递归算法**：需分析递归树深度和每层操作数（如斐波那契递归为 O(2ⁿ)）。
- **实际应用**：即使算法复杂度相同，常数项可能影响实际性能（如 O(n) 中 100n 比 n 慢）。