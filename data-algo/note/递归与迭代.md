### 2.2 迭代与递归总结

#### **1. 迭代（Iteration）**
- **定义**：通过循环结构重复执行任务，直到满足终止条件。
- **实现方式**：
  - **`for` 循环**：适合已知迭代次数的场景。
    - 示例：求和 `1 + 2 + ... + n`，时间复杂度为线性（O(n)）。
  - **`while` 循环**：更灵活，适合不确定迭代次数或条件复杂的场景。
    - 示例：条件变量可自由更新（如 `i++` 和 `i *= 2` 结合）。
  - **嵌套循环**：多层循环时，时间复杂度可能升至平方、立方等（如 O(n²)）。
- **特点**：
  - 显式控制流程，代码直观。
  - 通常空间效率高（无额外栈帧开销）。

#### **2. 递归（Recursion）**
- **定义**：函数调用自身分解问题，通过“递”和“归”两个阶段解决。
- **三要素**：
  1. **终止条件**：递归出口（如 `n == 1`）。
  2. **递归调用**：向更小规模问题分解（如 `recur(n - 1)`）。
  3. **返回结果**：组合子问题的解（如 `n + recur(n - 1)`）。
- **特点**：
  - **优点**：代码简洁，适合分治问题（如树、图、回溯等）。
  - **缺点**：
    - 栈帧空间开销大，可能栈溢出。
    - 存在重复计算（如斐波那契递归树）。
- **优化**：
  - **尾递归**：递归调用是函数的最后一步，可被编译器优化为迭代形式（但并非所有语言支持）。
    - 示例：`tailRecur(n - 1, res + n)` 直接返回递归结果，无后续操作。

#### **3. 对比与应用场景**
| **维度**       | **迭代**                     | **递归**                             |
| -------------- | ---------------------------- | ------------------------------------ |
| **实现**       | 循环结构（`for`/`while`）    | 函数自调用                           |
| **时间复杂度** | 通常更高效（无函数调用开销） | 可能因重复计算效率更低（如斐波那契） |
| **空间复杂度** | 固定内存（无栈帧累积）       | 栈帧累积，可能栈溢出                 |
| **适用问题**   | 线性任务（如遍历数组）       | 分治问题（如树、回溯、动态规划）     |

#### **4. 关键点**
- **递归与栈**：递归隐式使用调用栈，可显式用栈模拟递归（如迭代形式的 DFS）。
- **选择依据**：
  - **迭代**：简单任务、性能敏感场景。
  - **递归**：问题天然递归（如汉诺塔、快速排序），代码更易读。
- **注意事项**：
  - 递归深度限制（如 Python 默认约 1000 层）。
  - 尾递归优化需语言支持（如 C++ 支持，Python 不支持）。

#### **示例对比**
- **求和 `1 + 2 + ... + n`**：
  - 迭代：`for` 循环累加，O(1) 空间。
  - 递归：栈深度 O(n)，可能栈溢出。
- **斐波那契数列**：
  - 递归：O(2ⁿ) 时间（存在重复计算），可记忆化优化。
  - 迭代：O(n) 时间，O(1) 空间（推荐）。

#### **总结**
- **优先迭代**：当问题简单且需高效内存时。
- **选择递归**：当问题分治特性明显，或代码可读性更重要时。
- **转化递归为迭代**：通过显式栈管理状态，但可能增加代码复杂度。